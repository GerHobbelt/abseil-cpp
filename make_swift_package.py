#!/usr/bin/env python3

import sys
import os
import re
from typing import NamedTuple
from dataclasses import dataclass

#special handling of header search paths for time_zone
added_header_search_paths = {
   'time_zone': ['include/absl/time/internal/cctz/src']
}
added_linked_frameworks = {
   'time_zone': ['CoreFoundation']
}

package_template = """// swift-tools-version: 5.7
// The swift-tools-version declares the minimum version of Swift required to build this package.

// Auto generated by make_swift_package.py: https://github.com/ronnyf/abseil-cpp.git

import PackageDescription

let package = Package(
	name: "abseil-cpp",
	platforms: [
		.iOS(.v12),
		.macOS(.v10_13),
		.macCatalyst(.v13),
		.watchOS(.v5),
		.tvOS(.v11)
	],
	products: [
##PRODUCTS##
	],
    dependencies: [
##DEPENDENCIES## 
    ],
	targets: [
##TARGETS##
	],
	cLanguageStandard: .gnu11,
	cxxLanguageStandard: .gnucxx20
)
"""

class Target:
   name: str
   dependencies: list[str]
   headers: list[str]
   sources: list[str]
   path: str
   root_path: str
   is_public: bool
   is_testonly: bool
   ignored: list[str]
   header_search_paths: list[str]
   linked_frameworks: list[str]
  
   def make(self, library_info: dict):
      self.headers = []
      if 'HDRS' in library_info:
         self.headers = library_info['HDRS']
         if isinstance(self.headers, str):
            self.headers = [self.headers]
            
      self.sources = []
      if 'SRCS' in library_info:
         all_sources = library_info['SRCS']
         if isinstance(all_sources, str):
            all_sources = [all_sources]
         for source in all_sources:
            if source.endswith('.h') or source.endswith('.inc'):
               self.headers.append(source)
            else:
               self.sources.append(source)
      
      self.ignored_deps = []
      self.dependencies = []
      if 'DEPS' in library_info:
         self.dependencies = library_info['DEPS']
         if isinstance(self.dependencies, str):
            self.dependencies = [self.dependencies]
            
         converted_dependencies = []
         for dep in self.dependencies:
            converted_dep = Target.convert_dependency_name(dep)
            if converted_dep:
               converted_dependencies.append(converted_dep)
            else:
               print(f'debug: ignoring dep: {dep}')
               self.ignored_deps.append(dep)
         self.dependencies = converted_dependencies
         
      self.path = library_info['PATH']
      self.root_path = library_info['ROOT_PATH']
         
      self.is_testonly = 'TESTONLY' in library_info
      self.is_public = 'PUBLIC' in library_info
      self.header_search_paths = []
      self.linked_frameworks = []
      self.name = library_info['NAME']
   
   @staticmethod
   def convert_dependency_name(name: str, prefix: str = "absl::") -> str:
      if name.startswith(prefix):
         return name.removeprefix(prefix)
      if name == 'GTest::gtest':
         return '.product(name: "googletest", package: "googletest")'
      elif name == 'GTest::gmock':
         return '.product(name: "googlemock", package: "googletest")'
      return None
   
   def __init__(self, library_info: str, path: str, root_path: str):
      lines = library_info.splitlines()
      data = {}
      data['PATH'] = path
      data['ROOT_PATH'] = root_path
      current_key = None

      keywords = ['NAME', 'DEPS', 'HDRS', 'SRCS', 'COPTS', 'LINKOPTS', 'DEFINES', 'PUBLIC', 'TESTONLY']

      for line in lines:
         stripped_line = line.strip()
         stripped_line = stripped_line.replace('"', '')
         if len(stripped_line) == 0:
            continue
         
         if stripped_line in keywords:
            current_key = stripped_line
            if current_key == 'TESTONLY' or current_key == 'PUBLIC':
               data[current_key] = True
            continue
         else:
            # unhandled keyword, let's still try and identify it as a key
            if line == line.upper() and line == '  ' + stripped_line:
               current_key = stripped_line                  
               continue
            
         if current_key == 'NAME' or current_key == 'PATH':
            data[current_key] = stripped_line
         else:
            if current_key in data:
               data[current_key].append(stripped_line)
            else:
               data[current_key] = [stripped_line]

      self.make(library_info=data)

def find_cmakelists(root_path: str, path: str, targets: dict):
   if os.path.exists(path):
      for root, dirs, files in os.walk(path):
         for file_name in files:
            if file_name == 'CMakeLists.txt':
               file_path = os.path.join(root, file_name)
               parse_add_subdirectory(cmakelist_path=file_path, root_path=root_path, targets=targets)

def parse_add_subdirectory(cmakelist_path: str, root_path: str, targets: dict):
   # Read the content of the file
   try:
      with open(cmakelist_path, 'r') as file:
         file_content = file.read()
   except FileNotFoundError:
      print(f"File not found: {cmakelist_path}")
      return
   
   # Define the regular expression pattern
   pattern = r'add_subdirectory\((.*?)\)'

   # Use re.findall to extract all matches
   matches = re.findall(pattern, file_content)
   
   absl_path = os.path.join(root_path, 'absl')
   
   # enumerate matches and create subdirs
   for match in matches:
      file_name = match.strip()
      
      cm_path = os.path.join(absl_path, file_name)
      
      cm_file_path = os.path.join(cm_path, "CMakeLists.txt")
      if os.path.exists(cm_file_path):
         library_path = os.path.join('absl', file_name)
         extract_absl_cc_libraries(cmakelist_path=cm_file_path, root_path=root_path, subdir_path=library_path, targets=targets)
      
def extract_absl_cc_libraries(cmakelist_path: str, root_path: str, subdir_path: str, targets: dict):
   # Read the content of the file
   try:
      with open(cmakelist_path, 'r') as file:
         file_content = file.read()
   except FileNotFoundError:
      print(f"File not found: {cmakelist_path}")
      return []
   
   # Define the regular expression pattern
   pattern = r'absl_cc_library\((.*?)\)'

   # Use re.findall to extract all matches
   matches = re.finditer(pattern, file_content, re.DOTALL)
   
   # Process the matches and extract relevant information
   for match in matches:
      library_data = match.group(1)
      target = Target(library_info=library_data, path=subdir_path, root_path=root_path)
      targets[target.name] = target
      
      headers = [os.path.join(target.path, header) for header in target.headers]
      symlink_headers(headers=headers, root_path=target.root_path)
      
def symlink_headers(headers: list, root_path: str, dest_path: str = None):
   if os.path.exists(root_path) is False:
      raise FileNotFoundError(root_path)
   
   include_path = os.path.join(root_path ,'include')
   # internal_include_path = os.path.join(root_path ,'internal')
   
   for header in headers:
      dest = os.path.join(include_path, header)
      src = os.path.join(root_path, header)
      try:
         make_symlink(dest_path=dest, source_path=src)
      except:
         print(f'error: symlink failed: {src}')

def make_symlink(source_path: str, dest_path: str, relative: bool = True, overwrite: bool = True):
   if os.path.exists(source_path) is False:
      raise FileNotFoundError(source_path)
   
   if overwrite is False and os.path.exists(dest_path):
      return
   
   dest_path_dirname = os.path.dirname(dest_path)
   if os.path.exists(dest_path_dirname) is False:
      os.makedirs(dest_path_dirname, exist_ok=True)

   if relative is True:
      source_path = os.path.relpath(source_path, dest_path_dirname)

   if os.path.islink(dest_path):
      os.unlink(dest_path)
   if os.path.exists(dest_path):
      os.remove(dest_path)

   # print(f'os.symlink({source_path}, {dest_path})')
   os.symlink(source_path, dest_path)
   
def make_header_search_paths(targets: dict, target: Target, header_search_paths: set):
   for dependency in target.dependencies:
      if dependency not in targets:
         continue
      
      dep_target = targets[dependency]
      header_search_paths.update(dep_target.header_search_paths)
         
      make_header_search_paths(targets=targets, target=dep_target, header_search_paths=header_search_paths)
  
def prepareSwiftPackage(targets: dict, package_file_name: str = 'Package.swift', target_name_prefix: str = ''):
   package_products = '\t\t.library(name: "libabsl", targets: ["libabsl"]),'
   # package_dependencies = '\t\t.package(url: "https://github.com/ronnyf/googletest.git", .upToNextMajor(from: "1.14.0")),'
   package_dependencies = '\t\t.package(path: "../googletest"),'
   
   ignored_sources = {
      'internal/atomic_hook_test_helper.cc',
      'spinlock_test_common.cc',
      'internal/test_instance_tracker.cc',
      'internal/test_actions.cc',
      'internal/test_helpers.cc',
      'internal/test_matchers.cc',
      'internal/test_util.cc',
      'internal/per_thread_sem_test.cc',
      'internal/exception_safety_testing.cc',
      'scoped_mock_log.cc',
   }
   
   package_targets = targetWriter(targets=targets, ignored_sources=ignored_sources)
   
   with open('Package.swift', 'wt+') as file:
      package_description = package_template.replace('##DEPENDENCIES##', package_dependencies)
      package_description = package_description.replace('##PRODUCTS##', package_products)
      package_description = package_description.replace('##TARGETS##', package_targets)
      file.seek(0)
      file.write(package_description)
      file.truncate()
      
def targetWriter(targets: dict, ignored_sources: set) -> str:
   result = '\t\t.target(\n'
   result += '\t\t\tname: "libabsl",\n'
   # result += dependencyWriter()
   result += '\t\t\tpath: ".",\n'
   result += '\t\t\tsources: [\n'
   
   for target_name, target in targets.items():
      result += sourceWriter(target=target, ignored_sources=ignored_sources)
   
   result += '\t\t\t],\n'
   
   # public headers search path
   result += '\t\t\tpublicHeadersPath: "include",\n'
   
   # linker settings
   result += '\t\t\tlinkerSettings: [\n'
   result += '\t\t\t\t.linkedFramework("CoreFoundation")\n'
   result += '\t\t\t]\n'
   
   # end of target
   result += '\t\t),\n'

   return result
   
def sourceWriter(target: Target, ignored_sources: set) -> str:
   result = ''
   for source in target.sources:
      if source in ignored_sources:
         continue
      result += '\t\t\t\t"{}/{}",\n'.format(target.path, source)
   return result
   
def productWriter():
   print()
   
def dependencyWriter():
   result = '\t\t\tdependencies: [\n'
   result += '\t\t\t\t.product(name: "googletest", package: "googletest"),\n'
   result += '\t\t\t\t.product(name: "googlemock", package: "googletest"),\n'
   result += '\t\t\t],\n'
   return result
   
def writePackageDescription(targets: dict):
   package_file_name = 'Package.swift'
   
   package_products = ''
   # package_dependencies = '\t\t.package(url: "https://github.com/ronnyf/googletest.git", .upToNextMajor(from: "1.14.0")),'
   package_dependencies = '\t\t.package(path: "../googletest"),'
   
   target_name_prefix = 'absl_'
   
   ignored_targets = {
      'atomic_hook_test_helper'
   }
   
   for key, target in targets.items():
      if target.is_public and len(target.sources) > 0:
         if target.name in ignored_targets:
            continue
         package_products += '\t\t.library(\n\t\t\tname: "{}{}",\n\t\t\ttargets: [\n'.format(target_name_prefix, target.name)
         package_products += '\t\t\t\t"{}",\n'.format(target.name)
         package_products += '\t\t\t]),\n'
   
   package_products += '\t\t.library(name: "libabsl", targets: [\n'
   
   for key, target in targets.items():
      if target.name in ignored_targets:
            continue
      if len(target.sources) > 0:
         package_products += '\t\t\t"{}",\n'.format(target.name)
   
   package_products += '\t\t]),'
   package_targets = ''
   
   with open('Package.swift', 'wt+') as file:
      for index, (library_name, target) in enumerate(targets.items()):
         if len(target.sources) == 0 or target.name in ignored_targets:
            continue
         
         package_targets += "\t\t.target(\n"
         package_targets += '\t\t\tname: "{}",\n'.format(target.name)
      
         # dependencies
         if len(target.dependencies) > 0:
            package_targets += '\t\t\tdependencies: [\n'
            for dependency in target.dependencies:
               if dependency.startswith('.'):
                  print()
               else:
                  if dependency in targets:
                     target_dep = targets[dependency]
                     if len(target_dep.sources) == 0:
                        continue
                  dependency = '"{}"'.format(dependency)
               package_targets += '\t\t\t\t{},\n'.format(dependency)
            package_targets += '\t\t\t],\n'
         
         # path
         package_targets += '\t\t\tpath: ".",\n'
      
         # sources
         package_targets += '\t\t\tsources: [\n'
         for source in target.sources:
            source_with_prefix = os.path.join(target.path, source)
            package_targets += '\t\t\t\t"{}",\n'.format(source_with_prefix)
         package_targets += '\t\t\t],\n'
      
         # public headers search path
         package_targets += '\t\t\tpublicHeadersPath: "include"'
         
         header_search_paths = set(target.header_search_paths)
         make_header_search_paths(targets=targets, target=target, header_search_paths=header_search_paths)
         
         if target.name in added_header_search_paths:
            header_search_paths.update(added_header_search_paths[target.name])
         
         if len(header_search_paths) >0:
            package_targets += ',\n\t\t\tcSettings: [\n'
            for header_search_path in header_search_paths:
               package_targets += '\t\t\t\t.headerSearchPath("{}"),\n'.format(header_search_path)
            package_targets += '\t\t\t]'
   
         # linked frameworks
         if target.name in added_linked_frameworks:
            package_targets += ',\n\t\t\tlinkerSettings: [\n'
            for linkedFramework in added_linked_frameworks[target.name]:
               package_targets += '\t\t\t\t.linkedFramework("{}"),\n'.format(linkedFramework)
            package_targets += '\t\t\t]'
   
         package_targets += '\n'
         package_targets += '\t\t)'

         if index < len(targets):
            package_targets += ",\n"
      
      package_description = package_template.replace('##DEPENDENCIES##', package_dependencies)
      package_description = package_description.replace('##PRODUCTS##', package_products)
      package_description = package_description.replace('##TARGETS##', package_targets)
      file.seek(0)
      file.write(package_description)
      file.truncate()
   print(f'DONE!')

def main(argv):
   root_path = os.getcwd()
   absl_dir = os.path.join(root_path, 'absl')
   include_dir = os.path.join(root_path, 'include')
   
   if os.path.exists(include_dir) is False:
      os.makedirs(include_dir, exist_ok=True)
   
   targets = {}
   cache = {}
   
   find_cmakelists(root_path, absl_dir, targets)
   # for index, (target_name, target) in enumerate(targets.items()):
   #    print(f'make dep: {index}')
   #    header_deps = make_dependency_links(target=target, targets=targets, cache=cache)
   #    if len(header_deps) > 0:
   #       symlink_headers(headers=header_deps, root_path=target.root_path, dest_path=target.path)
         
   #now let's make a swift package...
   # writePackageDescription(targets=targets)
   prepareSwiftPackage(targets=targets)

if __name__ == '__main__':
  main(sys.argv)

